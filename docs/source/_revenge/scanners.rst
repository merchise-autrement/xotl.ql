====================================================================
 `xotl.ql.revenge.scanners`:mod: -- Scanners for Python expressions
====================================================================

.. module:: xotl.ql.revenge.scanners

.. role:: name


This files accompanies the module `scanners`:mod:.  It contains notes,
analysis that drive the current implementation.

The goal of this module is to get a stream of byte-code and produce another
stream of `Tokens <Token>`:class:.  Each token represents either an actual
byte-code instruction with is arguments, or a virtual instruction provided
solely for the purpose of making our `grammar <xotl.ql.revenge.parsers>`:mod:
easier to understand.

This modules derives from the work of `John Aycock`:name: and others on the
`uncompyle2`_ package.  However, since the goal of that package is much more
ambitious we have stripped much of the original grammar and the scanner has
been almost entirely reimplemented.

This document begins with an exploration of the byte-code for Python
expressions, and then describes the objects in the `scanners`:mod: module and
how the tokens are produced.


Expressions
===========

Let's inspect how simple expressions are compiled in different versions of
Python.


``a if x else y``

  In Python 2.7 and 3.4 this is compiled to::

    1           0 LOAD_NAME                0 (b)
                3 POP_JUMP_IF_FALSE       10
                6 LOAD_NAME                1 (a)
                9 RETURN_VALUE
          >>   10 LOAD_NAME                2 (c)
               13 RETURN_VALUE


  In Pypy 2.7.3::

    1           0 LOAD_NAME                0 (b)
                3 POP_JUMP_IF_FALSE       12
                6 LOAD_NAME                1 (a)
                9 JUMP_FORWARD             3 (to 15)
          >>   12 LOAD_NAME                2 (c)
          >>   15 RETURN_VALUE

  The difference is the 9th offset.

  It's easy to see we can provide an transformation step for Pypy byte-code so
  that the final byte-code is the same as that of CPython:

    If the target of a ``JUMP_FORWARD`` (or ``JUMP_ABSOLUTE``) is a
    ``RETURN_VALUE`` replace the JUMP with a ``RETURN_VALUE``.

  Notice, however, this affect the offsets since JUMP_FORWARD has an argument
  and RETURN_VALUE does not.  Then to keep things simple we can, provide the
  following rule:

    If the target of a ``JUMP_FORWARD`` (or ``JUMP_ABSOLUTE``) is a
    ``RETURN_VALUE`` replace the JUMP with the following instructions::

      RETURN_VALUE
      NOP
      NOP

  Notice we don't really care about optimization just normalization of the
  generated byte-code.  But since the grammar would be complicated with
  ``NOPs`` we must removed them afterwards.

  The algorithm for removing ``NOPs`` may be ported from the
  ``Python/peephole.c``.

  .. seealso:: The functions `without_nops`:func: and
               `normalize_pypy_conditional`:func:.



Toolkit
=======

.. autofunction:: without_nops

.. autofunction:: normalize_pypy_conditional

.. autoclass:: Token


.. _uncompyle2: https://github.com/mvaled/uncompyle2
