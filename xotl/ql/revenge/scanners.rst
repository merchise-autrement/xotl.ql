==========
 Scanners
==========

The scanner for a `query expression`:term:


Expressions
===========

``a if x else y``

  In Python 2.7 and 3.4 this is compiled to::

    1           0 LOAD_NAME                0 (b)
                3 POP_JUMP_IF_FALSE       10
                6 LOAD_NAME                1 (a)
                9 RETURN_VALUE
          >>   10 LOAD_NAME                2 (c)
               13 RETURN_VALUE


  In Pypy 2.7.3::

    1           0 LOAD_NAME                0 (b)
                3 POP_JUMP_IF_FALSE       12
                6 LOAD_NAME                1 (a)
                9 JUMP_FORWARD             3 (to 15)
          >>   12 LOAD_NAME                2 (c)
          >>   15 RETURN_VALUE

  The difference is the 9th offset.

  It's easy to see we can provide an transformation step for Pypy byte-code so
  that the final byte-code is the same as that of CPython:

    If the target of a ``JUMP_FORWARD`` (or ``JUMP_ABSOLUTE``) is a
    ``RETURN_VALUE`` replace the JUMP with a ``RETURN_VALUE``.

  Notice, however, this affect the offsets since JUMP_FORWARD has an argument
  and RETURN_VALUE does not.  Then to keep things simple we can, provide the
  following rule:

    If the target of a ``JUMP_FORWARD`` (or ``JUMP_ABSOLUTE``) is a
    ``RETURN_VALUE`` replace the JUMP with the following instructions::

      RETURN_VALUE
      NOP
      NOP

  Notice we don't really care about optimization just normalization of the
  generated byte-code.  But since the grammar would be complicated with
  ``NOPs`` we must removed them afterwards.

  The algorithm for removing ``NOPs`` may be ported from the
  ``Python/peephole.c``.  Basically they build a map from current offsets to
  offsets discounting previous NOPs, and then


``(a if x else y) if (b if z else c) else (d if o else p)``

  This is compiled to::




Design of our scanner
=====================
